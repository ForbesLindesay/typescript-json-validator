import {
  exec,
  getDefaultArgs,
  Args as TypeScriptJsonSchemaArgs,
} from 'typescript-json-schema';
import Ajv = require('ajv');
import {sync as spawnSync} from 'cross-spawn';
import {writeFileSync} from 'fs';
import {basename} from 'path';

const OUTPUT_FILENAME = '@typescript-json-validator';
let result: string | null = null;
const originalWriteFile = require('fs').writeFile;
require('fs').writeFile = (filename: string, src: string, ...args: any[]) => {
  if (filename === OUTPUT_FILENAME) {
    result = src;
    return;
  }
  return originalWriteFile(filename, src, ...args);
};

interface TemplatOptions {
  typeName: string;
  fileName: string;
  schema: string;
  useNamedExport: boolean;
  ajvOptions: Ajv.Options;
}
const template = ({
  typeName,
  useNamedExport,
  fileName,
  schema,
  ajvOptions,
}: TemplatOptions) => `// generated by typescript-json-validator

import Ajv = require('ajv');
import ${useNamedExport ? `{${typeName}}` : typeName} from './${fileName}';
import {inspect} from 'util';

const ajv = new Ajv(${JSON.stringify({
  coerceTypes: false,
  allErrors: true,
  ...ajvOptions,
})});

export {${typeName}};
export const ${typeName}Schema = ${schema}

ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));

type ValidateFunction = ((data: any) => data is ${typeName}) & Pick<Ajv.ValidateFunction, 'errors'>;
const validateSchema = ajv.compile(${typeName}Schema) as ValidateFunction;

export default function validate(value: unknown): ${typeName} {
  if (validateSchema(value)) {
    return value;
  } else {
    throw new Error(
      (validateSchema.errors
        ? validateSchema.errors.map(error => \`${typeName}\${error.dataPath} \${error.message}\`).join('\\n') +
          '\\n${typeName} value:\\n\\n'
        : null || 'Error validating ${typeName}:\\n\\n') + inspect(value),
    );
  }
}
`;

export interface Options {
  schema: Pick<
    TypeScriptJsonSchemaArgs,
    Exclude<keyof TypeScriptJsonSchemaArgs, 'out'>
  >;
  ajv: Ajv.Options;
  useNamedExport: boolean;
}
export interface ParsedArgs {
  fileName: string;
  typeName: string;
  options: Options;
}
export function parseArgs(args?: string[]): ParsedArgs {
  var helpText =
    'Usage: typescript-json-schema <path-to-typescript-file> <type>';
  const defaultArgs = getDefaultArgs();
  const parsedArgs = require('yargs')
    .usage(helpText)
    .demand(2)
    .boolean('refs')
    .default('refs', defaultArgs.ref)
    .describe('refs', 'Create shared ref definitions.')
    .boolean('aliasRefs')
    .default('aliasRefs', defaultArgs.aliasRef)
    .describe(
      'aliasRefs',
      'Create shared ref definitions for the type aliases.',
    )
    .boolean('topRef')
    .default('topRef', defaultArgs.topRef)
    .describe('topRef', 'Create a top-level ref definition.')
    .boolean('titles')
    .default('titles', defaultArgs.titles)
    .describe('titles', 'Creates titles in the output schema.')
    .boolean('defaultProps')
    // default to enabling default props
    .default('defaultProps', true)
    .describe('defaultProps', 'Create default properties definitions.')
    .boolean('noExtraProps')
    .default('noExtraProps', defaultArgs.noExtraProps)
    .describe(
      'noExtraProps',
      'Disable additional properties in objects by default.',
    )
    .boolean('propOrder')
    .default('propOrder', defaultArgs.propOrder)
    .describe('propOrder', 'Create property order definitions.')
    .boolean('typeOfKeyword')
    .default('typeOfKeyword', defaultArgs.typeOfKeyword)
    .describe(
      'typeOfKeyword',
      'Use typeOf keyword (https://goo.gl/DC6sni) for functions.',
    )
    .boolean('required')
    // default to requiring non-optional props
    .default('required', true)
    .describe('required', 'Create required array for non-optional properties.')
    .boolean('strictNullChecks')
    // default to strict null checks
    .default('strictNullChecks', true)
    .describe('strictNullChecks', 'Make values non-nullable by default.')
    .boolean('ignoreErrors')
    .default('ignoreErrors', defaultArgs.ignoreErrors)
    .describe('ignoreErrors', 'Generate even if the program has errors.')
    .array('validationKeywords')
    .default('validationKeywords', defaultArgs.validationKeywords)
    .describe(
      'validationKeywords',
      'Provide additional validation keywords to include.',
    )
    .boolean('excludePrivate')
    .default('excludePrivate', defaultArgs.excludePrivate)
    .describe('excludePrivate', 'Exclude private members from the schema.')
    .boolean('uniqueNames')
    .default('uniqueNames', defaultArgs.uniqueNames)
    .describe('uniqueNames', 'Use unique names for type symbols.')
    .array('include')
    .default('*', defaultArgs.include)
    .describe(
      'include',
      'Further limit tsconfig to include only matching files.',
    )
    .boolean('rejectDateType')
    .default('rejectDateType', defaultArgs.rejectDateType)
    .describe('rejectDateType', 'Rejects Date fields in type definitions.')
    .string('id')
    .default('id', defaultArgs.id)
    .describe('id', 'ID of schema.')
    .boolean('useNamedExport')
    .default('useNamedExport', false)
    .describe(
      'useNamedExport',
      'Type name is a named export, rather than the default export of the file',
    )
    .parse(args);
  return {
    fileName: parsedArgs._[0],
    typeName: parsedArgs._[1],
    options: {
      schema: {
        ref: parsedArgs.refs,
        aliasRef: parsedArgs.aliasRefs,
        topRef: parsedArgs.topRef,
        titles: parsedArgs.titles,
        defaultProps: parsedArgs.defaultProps,
        noExtraProps: parsedArgs.noExtraProps,
        propOrder: parsedArgs.propOrder,
        typeOfKeyword: parsedArgs.useTypeOfKeyword,
        required: parsedArgs.required,
        strictNullChecks: parsedArgs.strictNullChecks,
        ignoreErrors: parsedArgs.ignoreErrors,
        validationKeywords: parsedArgs.validationKeywords,
        include: parsedArgs.include,
        excludePrivate: parsedArgs.excludePrivate,
        uniqueNames: parsedArgs.uniqueNames,
        rejectDateType: parsedArgs.rejectDateType,
        id: parsedArgs.id,
      },
      ajv: {
        useDefaults: parsedArgs.defaultProps,
      },
      useNamedExport: parsedArgs.useNamedExport,
    },
  };
}

export function generateValidator(
  fileName: string,
  typeName: string,
  options: Options,
) {
  result = null;
  exec(fileName, typeName, {
    ...options.schema,
    out: OUTPUT_FILENAME,
  });
  if (!result) {
    throw new Error('typescript-json-schema did not produce any output');
  }
  return template({
    typeName,
    fileName: basename(fileName, /\.ts$/.test(fileName) ? '.ts' : '.tsx'),
    schema: result,
    ajvOptions: options.ajv,
    useNamedExport: options.useNamedExport,
  });
}

export default function run(args?: string[]) {
  const parsedArgs = parseArgs(args);
  const validator = generateValidator(
    parsedArgs.fileName,
    parsedArgs.typeName,
    parsedArgs.options,
  );
  const outputFileName = parsedArgs.fileName.replace(
    /\.tsx?$/,
    '.validator.ts',
  );
  writeFileSync(outputFileName, validator);

  let prettierPath;
  try {
    prettierPath = require.resolve('.bin/prettier');
  } catch (ex) {
    return;
  }
  spawnSync(prettierPath, [outputFileName, '--write']);
}
